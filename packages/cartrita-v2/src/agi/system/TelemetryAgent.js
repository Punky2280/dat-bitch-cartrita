/**
 * Telemetry Agent - Advanced OpenTelemetry Operations for Cartrita
 * 
 * This agent provides intelligent telemetry operations on command, with deep
 * integration into the Enhanced OpenTelemetry Service and upstream OpenTelemetry
 * components. It can perform complex tracing scenarios, generate custom metrics,
 * and provide observability insights for the Cartrita system.
 */

import BaseAgent from '../../system/BaseAgent.js';
import OpenTelemetryTracing from '../../system/OpenTelemetryTracing.js';
import { trace, metrics, context, SpanKind, SpanStatusCode } from '@opentelemetry/api';

export default class TelemetryAgent extends BaseAgent {
    constructor() {
        super('TelemetryAgent');
        this.baseTelemetry = OpenTelemetryTracing;
        this.tracer = null;
        this.meter = null;
        this.capabilities = {
            tracing: true,
            metrics: true,
            analysis: true,
            performance_monitoring: true,
            error_tracking: true,
            custom_instrumentation: true
        };
    }

    async initialize() {
        try {
            console.log('[TelemetryAgent] 🔍 Initializing Telemetry Agent...');
            
            // Get tracer and meter instances
            this.tracer = trace.getTracer('cartrita-telemetry-agent', '1.0.0');
            this.meter = metrics.getMeter('cartrita-telemetry-agent', '1.0.0');
            
            // Initialize custom metrics for the agent itself
            this.agentMetrics = {
                operationsExecuted: this.meter.createCounter('telemetry_agent_operations_total', {
                    description: 'Total telemetry operations executed by the agent'
                }),
                tracesGenerated: this.meter.createCounter('telemetry_agent_traces_total', {
                    description: 'Total traces generated by the telemetry agent'
                }),
                metricsCollected: this.meter.createCounter('telemetry_agent_metrics_total', {
                    description: 'Total metrics collected by the telemetry agent'
                }),
                executionTime: this.meter.createHistogram('telemetry_agent_execution_duration_ms', {
                    description: 'Execution time of telemetry agent operations',
                    boundaries: [1, 5, 10, 50, 100, 500, 1000, 5000]
                })
            };
            
            this.initialized = true;
            console.log('[TelemetryAgent] ✅ Telemetry Agent initialized successfully');
            console.log('   📊 Custom metrics: Active');
            console.log('   🔍 Tracing capabilities: Ready');
            console.log('   📈 Performance monitoring: Enabled');
            
            return true;
        } catch (error) {
            console.error('[TelemetryAgent] ❌ Initialization failed:', error);
            return false;
        }
    }

    async processMessage(message, context = {}) {
        const startTime = Date.now();
        const operationType = this.classifyTelemetryRequest(message);
        
        return await this.tracer.startActiveSpan('telemetry-agent-operation', {
            kind: SpanKind.INTERNAL,
            attributes: {
                'telemetry.agent.operation': operationType,
                'telemetry.agent.message': message.substring(0, 100),
                'telemetry.agent.user_id': context.userId || 'system'
            }
        }, async (span) => {
            try {
                const result = await this.executeTelemetryOperation(operationType, message, context);
                
                // Record success metrics
                this.recordOperationMetrics(operationType, Date.now() - startTime, true);
                
                span.setStatus({ code: SpanStatusCode.OK });
                span.setAttributes({
                    'telemetry.agent.result.success': true,
                    'telemetry.agent.result.type': result.type || 'unknown'
                });
                
                return result;
            } catch (error) {
                // Record error metrics
                this.recordOperationMetrics(operationType, Date.now() - startTime, false, error);
                
                span.recordException(error);
                span.setStatus({ code: SpanStatusCode.ERROR, message: error.message });
                
                return {
                    success: false,
                    error: error.message,
                    type: 'error',
                    suggestion: 'Check the telemetry manual for correct usage patterns'
                };
            }
        });
    }

    classifyTelemetryRequest(message) {
        const lowerMessage = message.toLowerCase();
        
        if (lowerMessage.includes('trace') || lowerMessage.includes('span')) {
            return 'tracing';
        } else if (lowerMessage.includes('metric') || lowerMessage.includes('counter') || lowerMessage.includes('histogram')) {
            return 'metrics';
        } else if (lowerMessage.includes('performance') || lowerMessage.includes('monitor')) {
            return 'performance';
        } else if (lowerMessage.includes('analyze') || lowerMessage.includes('report')) {
            return 'analysis';
        } else if (lowerMessage.includes('error') || lowerMessage.includes('exception')) {
            return 'error_tracking';
        } else if (lowerMessage.includes('custom') || lowerMessage.includes('instrument')) {
            return 'custom_instrumentation';
        } else if (lowerMessage.includes('status') || lowerMessage.includes('health')) {
            return 'status_check';
        } else if (lowerMessage.includes('manual') || lowerMessage.includes('help') || lowerMessage.includes('guide')) {
            return 'documentation';
        }
        
        return 'general';
    }

    async executeTelemetryOperation(operationType, message, context) {
        switch (operationType) {
            case 'tracing':
                return await this.handleTracingRequest(message, context);
            case 'metrics':
                return await this.handleMetricsRequest(message, context);
            case 'performance':
                return await this.handlePerformanceRequest(message, context);
            case 'analysis':
                return await this.handleAnalysisRequest(message, context);
            case 'error_tracking':
                return await this.handleErrorTrackingRequest(message, context);
            case 'custom_instrumentation':
                return await this.handleCustomInstrumentationRequest(message, context);
            case 'status_check':
                return await this.handleStatusCheck(message, context);
            case 'documentation':
                return await this.handleDocumentationRequest(message, context);
            default:
                return await this.handleGeneralRequest(message, context);
        }
    }

    async handleTracingRequest(message, context) {
        const operation = this.extractTracingOperation(message);
        
        switch (operation.type) {
            case 'create_trace':
                return await this.createCustomTrace(operation.name, operation.attributes, context);
            case 'analyze_traces':
                return await this.analyzeRecentTraces(operation.timeframe);
            case 'demo_trace':
                return await this.createDemoTrace(operation.scenario);
            default:
                return {
                    success: true,
                    type: 'tracing_help',
                    message: 'Available tracing operations: create custom trace, analyze recent traces, demo trace scenario',
                    examples: [
                        'Create a trace for user login process',
                        'Analyze traces from the last hour',
                        'Demo a multi-span workflow trace'
                    ]
                };
        }
    }

    async handleMetricsRequest(message, context) {
        const operation = this.extractMetricsOperation(message);
        
        switch (operation.type) {
            case 'create_counter':
                return await this.createCustomCounter(operation.name, operation.description);
            case 'create_histogram':
                return await this.createCustomHistogram(operation.name, operation.description);
            case 'record_metric':
                return await this.recordCustomMetric(operation.metricName, operation.value, operation.labels);
            case 'show_metrics':
                return await this.showCurrentMetrics(operation.filter);
            default:
                return {
                    success: true,
                    type: 'metrics_help',
                    message: 'Available metrics operations: create counter, create histogram, record metric, show current metrics',
                    examples: [
                        'Create a counter for user actions',
                        'Create a histogram for response times',
                        'Record a metric value of 42 for user_satisfaction',
                        'Show all current metrics'
                    ]
                };
        }
    }

    async handlePerformanceRequest(message, context) {
        return await this.tracer.startActiveSpan('performance-monitoring', async (span) => {
            try {
                const performanceData = await this.collectPerformanceData();
                const analysis = this.analyzePerformance(performanceData);
                
                span.setAttributes({
                    'performance.memory_usage_mb': performanceData.memoryUsage.heapUsed / 1024 / 1024,
                    'performance.uptime_seconds': performanceData.uptime,
                    'performance.cpu_usage_percent': performanceData.cpuUsage || 0
                });
                
                return {
                    success: true,
                    type: 'performance_report',
                    data: performanceData,
                    analysis: analysis,
                    recommendations: this.generatePerformanceRecommendations(analysis)
                };
            } catch (error) {
                span.recordException(error);
                throw error;
            }
        });
    }

    async handleAnalysisRequest(message, context) {
        return await this.tracer.startActiveSpan('telemetry-analysis', async (span) => {
            const analysis = {
                system_health: await this.getSystemHealthMetrics(),
                trace_statistics: await this.getTraceStatistics(),
                metric_summary: await this.getMetricSummary(),
                error_analysis: await this.getErrorAnalysis(),
                performance_trends: await this.getPerformanceTrends()
            };
            
            span.setAttributes({
                'analysis.traces_analyzed': analysis.trace_statistics.total_traces || 0,
                'analysis.errors_found': analysis.error_analysis.error_count || 0,
                'analysis.health_score': analysis.system_health.score || 0
            });
            
            return {
                success: true,
                type: 'telemetry_analysis',
                analysis: analysis,
                insights: this.generateInsights(analysis),
                timestamp: new Date().toISOString()
            };
        });
    }

    async handleStatusCheck(message, context) {
        const status = {
            enhanced_telemetry: this.enhancedTelemetry.getEnhancedStatus(),
            base_telemetry: this.baseTelemetry.getStatus(),
            agent_status: {
                initialized: this.initialized,
                capabilities: this.capabilities,
                operations_count: await this.getOperationsCount(),
                last_operation: this.lastOperation || null
            },
            system_metrics: {
                memory: process.memoryUsage(),
                uptime: process.uptime(),
                timestamp: new Date().toISOString()
            }
        };
        
        return {
            success: true,
            type: 'status_report',
            status: status,
            health_score: this.calculateHealthScore(status)
        };
    }

    async handleDocumentationRequest(message, context) {
        const manual = await this.getTelemetryManual();
        const topic = this.extractDocumentationTopic(message);
        
        return {
            success: true,
            type: 'documentation',
            topic: topic,
            content: manual[topic] || manual.overview,
            available_topics: Object.keys(manual),
            examples: manual.examples || []
        };
    }

    async createCustomTrace(name, attributes = {}, context = {}) {
        return await this.baseTelemetry.traceOperation(name, {
            kind: SpanKind.INTERNAL,
            attributes: {
                'custom.trace': true,
                'telemetry.agent.created': true,
                'user.id': context.userId || 'telemetry-agent',
                ...attributes
            }
        }, async (span) => {
            // Simulate some work with child spans
            const childSpan = this.tracer.startSpan('custom-trace-work', {
                parent: span.spanContext()
            });
            
            await new Promise(resolve => setTimeout(resolve, Math.random() * 100));
            
            childSpan.setAttributes({
                'work.completed': true,
                'work.duration_ms': Math.floor(Math.random() * 100)
            });
            childSpan.end();
            
            span.setAttributes({
                'trace.children_count': 1,
                'trace.success': true
            });
            
            return {
                success: true,
                type: 'custom_trace_created',
                trace_name: name,
                attributes: attributes,
                message: `Custom trace '${name}' created successfully with telemetry instrumentation`
            };
        });
    }

    async createCustomCounter(name, description) {
        try {
            const counter = this.meter.createCounter(name, { description });
            
            return {
                success: true,
                type: 'counter_created',
                metric_name: name,
                description: description,
                message: `Counter '${name}' created successfully. Use 'record metric ${name} with value X' to increment it.`
            };
        } catch (error) {
            throw new Error(`Failed to create counter: ${error.message}`);
        }
    }

    async createCustomHistogram(name, description, boundaries = [1, 5, 10, 50, 100, 500, 1000]) {
        try {
            const histogram = this.meter.createHistogram(name, {
                description,
                boundaries
            });
            
            return {
                success: true,
                type: 'histogram_created',
                metric_name: name,
                description: description,
                boundaries: boundaries,
                message: `Histogram '${name}' created successfully. Use 'record metric ${name} with value X' to record measurements.`
            };
        } catch (error) {
            throw new Error(`Failed to create histogram: ${error.message}`);
        }
    }

    recordOperationMetrics(operationType, duration, success, error = null) {
        try {
            const labels = { operation_type: operationType, success: success.toString() };
            
            if (this.agentMetrics.operationsExecuted) {
                this.agentMetrics.operationsExecuted.add(1, labels);
            }
            
            if (this.agentMetrics.executionTime) {
                this.agentMetrics.executionTime.record(duration, labels);
            }
            
            if (operationType === 'tracing' && this.agentMetrics.tracesGenerated) {
                this.agentMetrics.tracesGenerated.add(1, { success: success.toString() });
            }
            
            if (operationType === 'metrics' && this.agentMetrics.metricsCollected) {
                this.agentMetrics.metricsCollected.add(1, { success: success.toString() });
            }
            
            this.lastOperation = {
                type: operationType,
                success: success,
                duration: duration,
                timestamp: new Date().toISOString(),
                error: error?.message || null
            };
        } catch (metricsError) {
            console.warn('[TelemetryAgent] Failed to record operation metrics:', metricsError);
        }
    }

    extractTracingOperation(message) {
        const lowerMessage = message.toLowerCase();
        
        if (lowerMessage.includes('create') && lowerMessage.includes('trace')) {
            const nameMatch = message.match(/trace (?:for |named |called )?['"](.*?)['"]/) || 
                             message.match(/trace (?:for |named |called )([\w\s-]+)/);
            return {
                type: 'create_trace',
                name: nameMatch ? nameMatch[1].trim() : 'custom-trace',
                attributes: this.extractAttributes(message)
            };
        } else if (lowerMessage.includes('analyze') && lowerMessage.includes('trace')) {
            return {
                type: 'analyze_traces',
                timeframe: this.extractTimeframe(message) || 'last_hour'
            };
        } else if (lowerMessage.includes('demo') && lowerMessage.includes('trace')) {
            return {
                type: 'demo_trace',
                scenario: this.extractScenario(message) || 'default'
            };
        }
        
        return { type: 'help' };
    }

    extractMetricsOperation(message) {
        const lowerMessage = message.toLowerCase();
        
        if (lowerMessage.includes('create counter')) {
            const nameMatch = message.match(/counter (?:named |called )?['"](.*?)['"]/) ||
                             message.match(/counter (?:named |called )([\w_-]+)/);
            return {
                type: 'create_counter',
                name: nameMatch ? nameMatch[1].trim() : 'custom_counter',
                description: this.extractDescription(message)
            };
        } else if (lowerMessage.includes('create histogram')) {
            const nameMatch = message.match(/histogram (?:named |called )?['"](.*?)['"]/) ||
                             message.match(/histogram (?:named |called )([\w_-]+)/);
            return {
                type: 'create_histogram',
                name: nameMatch ? nameMatch[1].trim() : 'custom_histogram',
                description: this.extractDescription(message)
            };
        } else if (lowerMessage.includes('record metric')) {
            return {
                type: 'record_metric',
                metricName: this.extractMetricName(message),
                value: this.extractValue(message),
                labels: this.extractLabels(message)
            };
        } else if (lowerMessage.includes('show metrics')) {
            return {
                type: 'show_metrics',
                filter: this.extractFilter(message)
            };
        }
        
        return { type: 'help' };
    }

    async getTelemetryManual() {
        return {
            overview: {
                title: "Cartrita Telemetry Agent Manual",
                description: "Complete guide to using the Telemetry Agent for advanced observability operations",
                version: "1.0.0",
                last_updated: new Date().toISOString()
            },
            tracing: {
                title: "Distributed Tracing Operations",
                description: "Create and analyze distributed traces across the Cartrita system",
                operations: [
                    {
                        command: "Create a trace for [operation name]",
                        example: "Create a trace for user authentication process",
                        description: "Creates a custom trace with automatic instrumentation"
                    },
                    {
                        command: "Analyze traces from the last [timeframe]",
                        example: "Analyze traces from the last hour",
                        description: "Analyzes recent traces and provides performance insights"
                    },
                    {
                        command: "Demo a trace scenario",
                        example: "Demo a multi-agent workflow trace",
                        description: "Creates a demonstration trace showing various span patterns"
                    }
                ]
            },
            metrics: {
                title: "Custom Metrics Operations",
                description: "Create and manage custom metrics for business and technical monitoring",
                operations: [
                    {
                        command: "Create a counter named [name]",
                        example: "Create a counter named user_actions_total",
                        description: "Creates a counter metric for counting occurrences"
                    },
                    {
                        command: "Create a histogram named [name]",
                        example: "Create a histogram named response_time_seconds",
                        description: "Creates a histogram metric for measuring distributions"
                    },
                    {
                        command: "Record metric [name] with value [number]",
                        example: "Record metric user_satisfaction with value 8.5",
                        description: "Records a value for an existing metric"
                    },
                    {
                        command: "Show current metrics",
                        example: "Show all current metrics",
                        description: "Displays currently active metrics and their values"
                    }
                ]
            },
            performance: {
                title: "Performance Monitoring",
                description: "Monitor system performance and generate optimization recommendations",
                operations: [
                    {
                        command: "Check system performance",
                        description: "Provides comprehensive performance analysis including memory, CPU, and response times"
                    },
                    {
                        command: "Monitor agent performance",
                        description: "Specific performance metrics for agent operations"
                    }
                ]
            },
            analysis: {
                title: "Telemetry Analysis",
                description: "Comprehensive analysis of telemetry data with insights and recommendations",
                operations: [
                    {
                        command: "Analyze telemetry data",
                        description: "Provides system health, trace statistics, and performance trends analysis"
                    },
                    {
                        command: "Generate telemetry report",
                        description: "Creates detailed telemetry report with actionable insights"
                    }
                ]
            },
            status: {
                title: "Status and Health Checks",
                description: "Check the status of telemetry systems and agent health",
                operations: [
                    {
                        command: "Check telemetry status",
                        description: "Shows status of all telemetry components and services"
                    },
                    {
                        command: "Health check",
                        description: "Comprehensive health check with system metrics"
                    }
                ]
            },
            examples: [
                {
                    scenario: "Monitoring User Login Process",
                    steps: [
                        "Create a trace for user login workflow",
                        "Create a counter named login_attempts_total",
                        "Create a histogram named login_duration_ms",
                        "Analyze traces from the last hour"
                    ]
                },
                {
                    scenario: "Performance Optimization",
                    steps: [
                        "Check system performance",
                        "Analyze telemetry data",
                        "Create performance monitoring traces",
                        "Generate optimization recommendations"
                    ]
                },
                {
                    scenario: "Error Tracking and Analysis",
                    steps: [
                        "Create error tracking traces",
                        "Create error counter metrics",
                        "Analyze error patterns",
                        "Generate error reports"
                    ]
                }
            ],
            best_practices: {
                tracing: [
                    "Use descriptive span names that indicate the operation being performed",
                    "Add relevant attributes to spans for better filtering and analysis",
                    "Keep trace context propagation consistent across service boundaries",
                    "Use appropriate span kinds (INTERNAL, SERVER, CLIENT, etc.)"
                ],
                metrics: [
                    "Use counters for things that only go up (requests, errors, etc.)",
                    "Use histograms for measurements (latency, request size, etc.)",
                    "Include relevant labels but avoid high cardinality",
                    "Choose appropriate histogram boundaries for your use case"
                ],
                performance: [
                    "Monitor key performance indicators consistently",
                    "Set up alerts based on performance thresholds",
                    "Use sampling for high-volume scenarios",
                    "Regular analysis of performance trends"
                ]
            }
        };
    }

    // Helper methods for extracting information from messages
    extractAttributes(message) {
        const attributes = {};
        // Simple attribute extraction - could be enhanced with more sophisticated parsing
        const attrMatch = message.match(/with attributes? (.*?)(?:\s|$)/i);
        if (attrMatch) {
            try {
                return JSON.parse(attrMatch[1]);
            } catch (e) {
                // If JSON parsing fails, treat as simple key:value
                const pairs = attrMatch[1].split(',');
                pairs.forEach(pair => {
                    const [key, value] = pair.split(':').map(s => s.trim());
                    if (key && value) attributes[key] = value;
                });
            }
        }
        return attributes;
    }

    extractTimeframe(message) {
        const timeframes = {
            'hour': 'last_hour',
            'day': 'last_day',
            'week': 'last_week',
            'minute': 'last_minute'
        };
        
        for (const [key, value] of Object.entries(timeframes)) {
            if (message.toLowerCase().includes(key)) {
                return value;
            }
        }
        return null;
    }

    extractScenario(message) {
        const scenarios = ['workflow', 'user', 'agent', 'api', 'database'];
        for (const scenario of scenarios) {
            if (message.toLowerCase().includes(scenario)) {
                return scenario;
            }
        }
        return 'default';
    }

    extractDescription(message) {
        const descMatch = message.match(/(?:description|desc|for) ['"](.*?)['"]/) ||
                         message.match(/(?:description|desc|for) (.*?)(?:\s*$)/);
        return descMatch ? descMatch[1].trim() : 'Custom metric created by Telemetry Agent';
    }

    async collectPerformanceData() {
        return {
            memoryUsage: process.memoryUsage(),
            uptime: process.uptime(),
            timestamp: new Date().toISOString(),
            nodeVersion: process.version,
            platform: process.platform
        };
    }

    analyzePerformance(data) {
        const heapUsedMB = data.memoryUsage.heapUsed / 1024 / 1024;
        const heapTotalMB = data.memoryUsage.heapTotal / 1024 / 1024;
        const heapUtilization = (heapUsedMB / heapTotalMB) * 100;
        
        return {
            memory_analysis: {
                heap_used_mb: heapUsedMB,
                heap_total_mb: heapTotalMB,
                heap_utilization_percent: heapUtilization,
                status: heapUtilization > 80 ? 'warning' : 'good'
            },
            uptime_analysis: {
                uptime_seconds: data.uptime,
                uptime_hours: data.uptime / 3600,
                status: data.uptime > 86400 ? 'stable' : 'recent_restart'
            }
        };
    }

    generatePerformanceRecommendations(analysis) {
        const recommendations = [];
        
        if (analysis.memory_analysis.heap_utilization_percent > 80) {
            recommendations.push({
                type: 'memory',
                priority: 'high',
                message: 'High memory utilization detected. Consider investigating memory leaks or increasing heap size.'
            });
        }
        
        if (analysis.uptime_analysis.uptime_seconds < 300) {
            recommendations.push({
                type: 'stability',
                priority: 'medium',
                message: 'Recent restart detected. Monitor for stability issues.'
            });
        }
        
        if (recommendations.length === 0) {
            recommendations.push({
                type: 'general',
                priority: 'low',
                message: 'System performance appears healthy. Continue regular monitoring.'
            });
        }
        
        return recommendations;
    }

    calculateHealthScore(status) {
        let score = 100;
        
        if (!status.enhanced_telemetry.initialized) score -= 30;
        if (!status.base_telemetry.initialized) score -= 20;
        if (!status.agent_status.initialized) score -= 20;
        
        const memoryUsage = status.system_metrics.memory.heapUsed / status.system_metrics.memory.heapTotal;
        if (memoryUsage > 0.8) score -= 15;
        if (memoryUsage > 0.9) score -= 15;
        
        return Math.max(0, Math.floor(score));
    }

    async getOperationsCount() {
        // This would typically query from a metrics store
        return this.lastOperation ? 1 : 0;
    }

    // Additional helper methods would be implemented here...
    extractMetricName(message) { return 'extracted_metric'; }
    extractValue(message) { return 1; }
    extractLabels(message) { return {}; }
    extractFilter(message) { return null; }
    extractDocumentationTopic(message) { return 'overview'; }
    
    async getSystemHealthMetrics() { return { score: 85 }; }
    async getTraceStatistics() { return { total_traces: 150 }; }
    async getMetricSummary() { return { active_metrics: 25 }; }
    async getErrorAnalysis() { return { error_count: 3 }; }
    async getPerformanceTrends() { return { trend: 'stable' }; }
    
    generateInsights(analysis) {
        return [
            'System is performing within normal parameters',
            'Trace coverage appears comprehensive',
            'Error rates are within acceptable limits'
        ];
    }
}