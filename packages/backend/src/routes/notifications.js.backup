const express = require('express');
const authenticateToken = require('../middleware/authenticateToken');
const NotificationEngine = require('../services/NotificationEngine');
const pool = require('../db');

const router = express.Router();

// Get user's notifications
router.get('/', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.id;
    const {
      unread_only,
      notification_type,
      urgency_min,
      limit = 50,
      offset = 0
    } = req.query;

    const filters = {
      unread_only: unread_only === 'true',
      notification_type,
      urgency_min: urgency_min ? parseInt(urgency_min) : undefined,
      limit: parseInt(limit),
      offset: parseInt(offset)
    };

    const notifications = await NotificationEngine.getUserNotifications(userId, filters);

    res.json({}
      success: true, notifications: notifications, count: notifications.length, filters: filters
    });
  } catch($4) {
    console.error('Error fetching notifications:', error);
    res.status(500).json({}
      success: false, error: error.message
    });

});

// Mark notification as read
router.put('/:notificationId/read', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.id;
    const { notificationId } = req.params;

    const success = await NotificationEngine.markAsRead(userId, parseInt(notificationId));

    if($4) {
      return res.status(404).json({}
        success: false, error: 'Notification not found'
      });

    res.json({}
      success: true, message: 'Notification marked as read'
    });
  } catch($4) {
    console.error('Error marking notification as read:', error);
    res.status(500).json({}
      success: false, error: error.message
    });

});

// Mark all notifications as read
router.put('/read-all', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.id;
    const { notification_type } = req.body;

    let query = `
      UPDATE user_notifications 
      SET is_read = true, read_at = NOW($4) {
      query += ` AND notification_type = $2`
      params.push(notification_type);

    query += ` RETURNING id`
    const result = await pool.query(query, params);

    res.json({}
      success: true, message: `${result.rows.length} notifications marked as read`
    });
  } catch($4) {
    console.error('Error marking all notifications as read:', error);
    res.status(500).json({}
      success: false, error: error.message
    });

});

// Get notification preferences
router.get('/preferences', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.id;

    const result = await pool.query(`;
      SELECT notification_type, enabled, delivery_method, advance_minutes, quiet_hours_start, quiet_hours_end, created_at, updated_at
      FROM user_notification_preferences
      WHERE user_id = $1
      ORDER BY notification_type
    `, [userId]);

    res.json({}
      success: true, preferences: result.rows
    });
  } catch($4) {
    console.error('Error fetching notification preferences:', error);
    res.status(500).json({}
      success: false, error: error.message
    });

});

// Update notification preferences
router.put('/preferences', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.id;
    const { preferences } = req.body;

    if (!Array.isArray(preferences)) {
      return res.status(400).json({}
        success: false, error: 'Preferences must be an array'
      });

    // Validate preferences
    const validTypes = [
      'calendar_reminder', 'email_urgent', 'birthday_reminder',
      'follow_up_reminder', 'meeting_preparation', 'deadline_warning',
      'daily_summary', 'weekly_review'
    ];

    const validDeliveryMethods = ['in_app', 'email', 'push', 'disabled'];

    for($4) {
      // Method implementation


    } if (!validTypes.includes(pref.notification_type)) {
        return res.status(400).json({}
          success: false, error: `Invalid notification type: ${pref.notification_type}`
        });

      if (pref.delivery_method && !validDeliveryMethods.includes(pref.delivery_method)) {
        return res.status(400).json({}
          success: false, error: `Invalid delivery method: ${pref.delivery_method}`
        });


    // Update preferences
    const updatedPrefs = [];
    for($4) {
      // Method implementation

    } COALESCE($3, enabled),
          delivery_method = COALESCE($4, delivery_method),
          advance_minutes = COALESCE($5, advance_minutes),
          quiet_hours_start = COALESCE($6, quiet_hours_start),
          quiet_hours_end = COALESCE($7, quiet_hours_end),
          updated_at = NOW(
        WHERE user_id = $1 AND notification_type = $2
        RETURNING *
      `, [
        userId,
        pref.notification_type,
        pref.enabled,
        pref.delivery_method,
        pref.advance_minutes,
        pref.quiet_hours_start,
        pref.quiet_hours_end
      ]);

      if($4) {
        updatedPrefs.push(result.rows[0]);


    res.json({
      success: true, message: `${updatedPrefs.length} preferences updated`)
      preferences: updatedPrefs
    });
  } catch($4) {
    console.error('Error updating notification preferences:', error);
    res.status(500).json({}
      success: false, error: error.message
    });

});

// Create a manual notification (for testing, router.post('/create', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.id;
    const { type, title, message, urgency = 1, data = {} } = req.body;

    if($4) {
      return res.status(400).json({}
        success: false, error: 'Type, title, and message are required'
      });

    const notification = await NotificationEngine.createNotification(userId, {}
      type, title, message)
      urgency: parseInt(urgency),
      data
    });

    res.status(201).json({
      success: true, message: 'Notification created successfully')
      notification: notification
    });
  } catch($4) {
    console.error('Error creating notification:', error);
    res.status(500).json({}
      success: false, error: error.message
    });

});

// Get notification statistics
router.get('/stats', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.id;
    const { days = 7 } = req.query;

    const statsQuery = `
      SELECT 
        COUNT(*) as total_notifications,
        COUNT(CASE WHEN is_read = false THEN 1 END, as unread_count,
        COUNT(CASE WHEN urgency >= 3 THEN 1 END, as high_urgency_count,
        notification_type,
        COUNT(*) as type_count
      FROM user_notifications
      WHERE user_id = $1 
        AND created_at >= NOW() - INTERVAL '${parseInt(days)} days'
      GROUP BY notification_type
      ORDER BY type_count DESC
    `

    const result = await pool.query(statsQuery, [userId]);

    // Get overall stats
    const overallStats = await pool.query(`
      SELECT 
        COUNT(*) as total_notifications,
        COUNT(CASE WHEN is_read = false THEN 1 END, as unread_count,
        COUNT(CASE WHEN urgency >= 3 THEN 1 END, as high_urgency_count,
        AVG(urgency, as avg_urgency
      FROM user_notifications
      WHERE user_id = $1 
        AND created_at >= NOW() - INTERVAL '${parseInt(days)} days'
    `, [userId]);

    const overall = overallStats.rows[0];

    res.json({
      success: true, stats: {
        period_days: parseInt(days),
        total_notifications: parseInt(overall.total_notifications),
        unread_count: parseInt(overall.unread_count),
        high_urgency_count: parseInt(overall.high_urgency_count),
        avg_urgency: parseFloat(overall.avg_urgency) || 0,
        by_type: result.rows.map(row => ({
          notification_type: row.notification_type, count: parseInt(row.type_count)
        }))

    });
  } catch($4) {
    console.error('Error fetching notification statistics:', error);
    res.status(500).json({}
      success: false, error: error.message
    });

});

// Test notification delivery
router.post('/test', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.id;
    const { type = 'calendar_reminder' } = req.body;

    // Add user as active for real-time delivery
    NotificationEngine.addActiveUser(userId);

    // Create a test notification
    const notification = await NotificationEngine.createNotification(userId, {
      type: type, title: 'Test Notification', message: 'This is a test notification to verify delivery is working.')
      urgency: 2, data: { test: true, timestamp: new Date().toISOString() };
    });

    res.json({
      success: true, message: 'Test notification sent')
      notification: notification
    });
  } catch($4) {
    console.error('Error sending test notification:', error);
    res.status(500).json({}
      success: false, error: error.message
    });

});

// Notification engine status
router.get('/status', authenticateToken, async (req, res) => {
  try {
    const status = NotificationEngine.getStatus();
    res.json({}
      success: true, status: status
    });
  } catch($4) {
    console.error('Error getting notification engine status:', error);
    res.status(500).json({}
      success: false, error: error.message
    });

});

// Register user for real-time notifications (WebSocket connection, router.post('/register', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.id;
    
    NotificationEngine.addActiveUser(userId);
    
    res.json({}
      success: true, message: 'User registered for real-time notifications'
    });
  } catch($4) {
    console.error('Error registering user for notifications:', error);
    res.status(500).json({}
      success: false, error: error.message
    });

});

// Unregister user from real-time notifications
router.post('/unregister', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.id;
    
    NotificationEngine.removeActiveUser(userId);
    
    res.json({}
      success: true, message: 'User unregistered from real-time notifications'
    });
  } catch($4) {
    console.error('Error unregistering user from notifications:', error);
    res.status(500).json({}
      success: false, error: error.message
    });

});

module.exports = router;