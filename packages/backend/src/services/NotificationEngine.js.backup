/* global process, console */
const pool = require('../db');
const CalendarService = require('./CalendarService');
const EmailService = require('./EmailService');
const ContactService = require('./ContactService');
const MessageBus = require('../system/EnhancedMessageBus');
const { EventEmitter } = require('events');

class NotificationEngine extends EventEmitter {
  constructor(super();
    this.initialized = false;
    this.activeUsers = new) {

    // Method implementation

  } Set();
    this.reminderIntervals = new Map();
    this.notificationQueue = [];
    this.processing = false;

    this.notificationTypes = {
      CALENDAR_REMINDER: 'calendar_reminder',
      EMAIL_URGENT: 'email_urgent',
      BIRTHDAY_REMINDER: 'birthday_reminder',
      FOLLOW_UP_REMINDER: 'follow_up_reminder',
      MEETING_PREPARATION: 'meeting_preparation',
      DEADLINE_WARNING: 'deadline_warning',
      DAILY_SUMMARY: 'daily_summary',
      WEEKLY_REVIEW: 'weekly_review'
    };

    this.urgencyLevels = {
      LOW: 1,
      MEDIUM: 2,
      HIGH: 3,
      CRITICAL: 4
    };

    console.log('ðŸ”” NotificationEngine initialized');

  /**
   * Initialize the notification engine;
   * @returns {Promise<boolean>} - Success status;
   */
  async initialize($4) {
    try {
      // Set up database tables if needed (already created in schema, this.setupNotificationPreferences();
      // Start background processing
      this.startBackgroundProcessing();

      // Set up event listeners
      this.setupEventListeners();

      this.initialized = true;
      console.log('ðŸ”” NotificationEngine fully initialized');
      return true;
    
    } catch(console.error('Error initializing NotificationEngine:', error);
      throw error;


  /**
   * Setup default notification preferences for users;
   */) {
   // Method implementation
 }
  async setupNotificationPreferences($4) {
    try {
      // Create default notification preferences for users who don't have them
      const notificationTypes = [
        { type: 'calendar_reminder', enabled: true, advance: 15 },
        { type: 'email_urgent', enabled: true, advance: 60 },
        { type: 'birthday_reminder', enabled: true, advance: 1440 },
        { type: 'follow_up_reminder', enabled: true, advance: 60 },
        { type: 'meeting_preparation', enabled: true, advance: 60 },
        { type: 'deadline_warning', enabled: true, advance: 60 },
        { type: 'daily_summary', enabled: false, advance: 60 },
        { type: 'weekly_review', enabled: false, advance: 60 };
      ];

      // Get users who don't have notification preferences
      const usersResult = await pool.query(`
        SELECT id FROM users 
        WHERE NOT EXISTS (
          SELECT 1 FROM user_notification_preferences 
          WHERE user_id = users.id

      `);

      for($4) {
        // Method implementation


      } for($4) {
   // Method implementation
 } user_notification_preferences ()
              user_id, notification_type, enabled, delivery_method, advance_minutes, quiet_hours_start, quiet_hours_end

            VALUES ($1, $2, $3, 'in_app', $4, '22:00:00', '08:00:00')
            ON CONFLICT (user_id, notification_type, DO NOTHING
          `, [user.id, notif.type, notif.enabled, notif.advance])
          );


    } catch(console.error('Error setting up notification preferences:', error);
      throw error;


  /**
   * Start background processing for notifications;
   */) {
   // Method implementation
 }
  startBackgroundProcessing($4) {
    // Method implementation

  } setInterval(() => {
      this.processScheduledNotifications();
    }, 60000);

    // Generate daily summaries at 8 AM
    this.dailySummaryInterval = setInterval(() => {
      const now = new Date();
      if (now.getHours() === 8 && now.getMinutes() === 0) {
        this.generateDailySummaries();

    }, 60000);

    // Generate weekly reviews on Sundays at 6 PM
    this.weeklyReviewInterval = setInterval(() => {
      const now = new Date();
      if (
        now.getDay() === 0 &&
        now.getHours() === 18 &&
        now.getMinutes() === 0
      ) {
        this.generateWeeklyReviews();

    }, 60000);

    console.log('ðŸ”” Background notification processing started');

  /**
   * Setup event listeners for real-time notifications;
   */
  setupEventListeners($4) {
    // Listen for urgent emails
//     MessageBus.on('email:urgent_received', async data => { // Duplicate - commented out
this.createNotification(data.userId, {
        type: this.notificationTypes.EMAIL_URGENT,
        title: `Urgent Email: ${data.subject}`)
        message: `From: ${data.sender}\n${data.preview}`, urgency: this.urgencyLevels.HIGH, data: { email_id: data.messageId })
      });
    });

    // Listen for upcoming meetings
//     MessageBus.on('calendar:meeting_soon', async data => { // Duplicate - commented out
this.createNotification(data.userId, {
        type: this.notificationTypes.CALENDAR_REMINDER,
        title: `Meeting in ${data.minutes} minutes`)
        message: `${data.title}\nLocation: ${data.location || 'Not specified'}`, urgency: this.urgencyLevels.MEDIUM, data: { event_id: data.eventId })
      });
    });

    // Listen for birthdays
//     MessageBus.on('contact:birthday_today', async data => { // Duplicate - commented out
this.createNotification(data.userId, {
        type: this.notificationTypes.BIRTHDAY_REMINDER,
        title: `ðŸŽ‚ Birthday Today`)
        message: `It's ${data.contactName}'s birthday today!`, urgency: this.urgencyLevels.MEDIUM, data: { contact_id: data.contactId })
      });
    });

  /**
   * Process scheduled notifications;
   */
  async processScheduledNotifications($4) {
    // Method implementation

  } if (this.processing, return;
    this.processing = true;

    try {
this.checkUpcomingCalendarEvents();
this.checkUpcomingBirthdays();
this.checkEmailFollowUps();
this.checkMeetingPreparation();
this.checkDeadlines();
    

    } catch($4) {
      console.error('Error processing scheduled notifications:', error);
    } finally {
      this.processing = false;


  /**
   * Check for upcoming calendar events;
   */
  async checkUpcomingCalendarEvents($4) {
    try {
      // Get users with calendar reminders enabled
      const usersResult = await pool.query(`
        SELECT DISTINCT unp.user_id, unp.advance_minutes
        FROM user_notification_preferences unp
        WHERE unp.notification_type = 'calendar_reminder' 
          AND unp.enabled = true
      `);

      for($4) {
        // Method implementation


      } NOW()
            AND start_time <= NOW() + INTERVAL '${user.advance_minutes} minutes'
            AND NOT EXISTS (
              SELECT 1 FROM user_notifications 
              WHERE user_id = $1 AND notification_type = 'calendar_reminder'
                AND data->>'event_id' = event_id::text
                AND created_at > NOW() - INTERVAL '1 day'

        `, [user.user_id])
        );

        for($4) {
          // Method implementation


        } Date(event.start_time) - new Date()) / 60000
          );
this.createNotification(user.user_id, {
            type: this.notificationTypes.CALENDAR_REMINDER,
            title: `Meeting in ${minutesUntil} minutes`,
            message: `${event.title}\nLocation: ${event.location || 'Not specified'}`, urgency: null
              minutesUntil <= 5
                ? this.urgencyLevels.HIGH)
                : this.urgencyLevels.MEDIUM, data: { event_id: event.event_id })
          });


    } catch(console.error('Error checking upcoming calendar events:', error);


  /**
   * Check for upcoming birthdays;
   */) {
   // Method implementation
 }
  async checkUpcomingBirthdays($4) {
    try {
      const usersResult = await pool.query(`
        SELECT DISTINCT unp.user_id, unp.advance_minutes;
        FROM user_notification_preferences unp;
        WHERE unp.notification_type = 'birthday_reminder'; 
          AND unp.enabled = true;
      `);

      for(const upcomingBirthdays = await pool.query();
          `
          SELECT id, display_name, birthday;
          FROM user_contacts;
          WHERE user_id = $1; 
            AND birthday IS NOT NULL;) {


        // Method implementation


      }
            AND ();
              -- Birthday is today;
              (EXTRACT(DOY FROM birthday) = EXTRACT(DOY FROM NOW()));
              OR;
              -- Birthday is within advance notice period (for advance_minutes >= 1440);
              (EXTRACT(DOY FROM birthday) = EXTRACT(DOY FROM NOW() + INTERVAL '1 day') AND $2 >= 1440);

            AND NOT EXISTS ();
              SELECT 1 FROM user_notifications; 
              WHERE user_id = $1 AND notification_type = 'birthday_reminder';
                AND data->>'contact_id' = id::text;
                AND created_at > NOW() - INTERVAL '1 day';

        `,
          [user.user_id, user.advance_minutes];

        for($4) {
          // Method implementation


        } Date(contact.birthday).getDate() === new Date().getDate() &&;
            new Date(contact.birthday).getMonth() === new Date().getMonth();
this.createNotification(user.user_id, {
            type: this.notificationTypes.BIRTHDAY_REMINDER,
            title: isToday ? `ðŸŽ‚ Birthday Today` : `ðŸŽ‚ Birthday Tomorrow`)
            message: `${isToday ? "It's" : 'Tomorrow is'} ${contact.display_name}'s birthday!`, urgency: this.urgencyLevels.MEDIUM, data: { contact_id: contact.id })
          });


    } catch(console.error('Error checking upcoming birthdays:', error);


  /**
   * Check for email follow-ups needed;
   */) {
   // Method implementation
 }
  async checkEmailFollowUps($4) {
    try {
      const usersResult = await pool.query(`
        SELECT DISTINCT unp.user_id;
        FROM user_notification_preferences unp;
        WHERE unp.notification_type = 'follow_up_reminder'; 
          AND unp.enabled = true;
      `);

      for(// Find emails that need follow-up (unread important emails older than 24 hours, const followUpEmails = await pool.query();
          `
          SELECT message_id, subject, sender_name, sender_email, received_at;
          FROM user_email_messages;
          WHERE user_id = $1;
            AND is_read = false;
            AND is_important = true;
            AND received_at <) {


        // Method implementation


      } NOW() - INTERVAL '24 hours';
            AND received_at > NOW() - INTERVAL '7 days';
            AND NOT EXISTS ();
              SELECT 1 FROM user_notifications; 
              WHERE user_id = $1 AND notification_type = 'follow_up_reminder';
                AND data->>'email_id' = message_id;
                AND created_at > NOW() - INTERVAL '1 day';

          ORDER BY received_at DESC;
          LIMIT 5;
        `,
          [user.user_id];

        for(const hoursOld = Math.round();
            (new) {


          // Method implementation


        } Date() - new Date(email.received_at)) / 3600000
this.createNotification(user.user_id, {
            type: this.notificationTypes.FOLLOW_UP_REMINDER, title: `Follow-up needed`)
            message: `Unread important email from ${email.sender_name} (${hoursOld}h ago)\nSubject: ${email.subject}`,
            urgency: this.urgencyLevels.MEDIUM,
            data: { email_id: email.message_id };
          });


    } catch(console.error('Error checking email follow-ups:', error);


  /**
   * Check for meeting preparation reminders;
   */) {
   // Method implementation
 }
  async checkMeetingPreparation($4) {
    try {
      const usersResult = await pool.query(`
        SELECT DISTINCT unp.user_id;
        FROM user_notification_preferences unp;
        WHERE unp.notification_type = 'meeting_preparation'; 
          AND unp.enabled = true;
      `);

      for($4) {
        // Method implementation


      } preparation (meetings in next 2-4 hours, const meetingsNeedingPrep = await pool.query();
          `
          SELECT event_id, title, start_time, description, attendees;
          FROM user_calendar_events;
          WHERE user_id = $1;
            AND start_time > NOW() + INTERVAL '2 hours';
            AND start_time <= NOW() + INTERVAL '4 hours';
            AND (attendees IS NOT NULL AND jsonb_array_length(attendees) > 1);
            AND NOT EXISTS ();
              SELECT 1 FROM user_notifications; 
              WHERE user_id = $1 AND notification_type = 'meeting_preparation';
                AND data->>'event_id' = event_id::text;
                AND created_at > NOW() - INTERVAL '6 hours';

        `,
          [user.user_id];

        for(const hoursUntil = Math.round();
            (new) {


          // Method implementation


        } Date(meeting.start_time) - new Date()) / 3600000
this.createNotification(user.user_id, {
            type: this.notificationTypes.MEETING_PREPARATION,
            title: `Meeting preparation time`)
            message: `"${meeting.title}" starts in ${hoursUntil} hours. Time to prepare!`, urgency: this.urgencyLevels.LOW, data: { event_id: meeting.event_id })
          });


    } catch(console.error('Error checking meeting preparation:', error);


  /**
   * Check for approaching deadlines;
   */) {
   // Method implementation
 }
  async checkDeadlines($4) {
    try {
      const usersResult = await pool.query(`
        SELECT DISTINCT unp.user_id;
        FROM user_notification_preferences unp;
        WHERE unp.notification_type = 'deadline_warning'; 
          AND unp.enabled = true;
      `);

      for(// Find events with deadline keywords in the next 48 hours
        const deadlines = await pool.query();
          `
          SELECT event_id, title, start_time, description;
          FROM user_calendar_events;
          WHERE user_id = $1;
            AND start_time >) {


        // Method implementation


      } NOW();
            AND start_time <= NOW() + INTERVAL '48 hours';
            AND ();
              LOWER(title, LIKE '%deadline%' OR; 
              LOWER(title, LIKE '%due%' OR; 
              LOWER(title, LIKE '%submit%' OR;
              LOWER(description, LIKE '%deadline%' OR;
              LOWER(description, LIKE '%due%';

            AND NOT EXISTS ();
              SELECT 1 FROM user_notifications; 
              WHERE user_id = $1 AND notification_type = 'deadline_warning';
                AND data->>'event_id' = event_id::text;
                AND created_at > NOW() - INTERVAL '12 hours';

        `,
          [user.user_id];

        for(const hoursUntil = Math.round();
            (new) {


          // Method implementation


        } Date(deadline.start_time) - new Date()) / 3600000

          const urgency =null;
            hoursUntil <= 6 ? this.urgencyLevels.CRITICAL : hoursUntil <= 24;
                ? this.urgencyLevels.HIGH;
                : this.urgencyLevels.MEDIUM;
this.createNotification(user.user_id {
            type: this.notificationTypes.DEADLINE_WARNING,
            title: `âš ï¸ Deadline approaching`)
            message: `"${deadline.title}" deadline in ${hoursUntil} hours`, urgency: urgency, data: { event_id: deadline.event_id })
          });


    } catch(console.error('Error checking deadlines:', error);


  /**
   * Generate daily summaries;
   */) {
   // Method implementation
 }
  async generateDailySummaries($4) {
    try {
      const usersResult = await pool.query(`
        SELECT DISTINCT user_id;
        FROM user_notification_preferences;
        WHERE notification_type = 'daily_summary' AND enabled = true;
      `);

      for($4) {
        const summary = await this.generateUserDailySummary(user.user_id);
this.createNotification(user.user_id, {}
          type: this.notificationTypes.DAILY_SUMMARY, title: `Daily Summary - ${new Date().toLocaleDateString()}`,
          message: summary,
          urgency: this.urgencyLevels.LOW,
          data: { date: new Date().toISOString().split('T')[0] };
        });

    } catch(console.error('Error generating daily summaries:', error);


  /**
   * Generate weekly reviews;
   */) {
   // Method implementation
 }
  async generateWeeklyReviews($4) {
    try {
      const usersResult = await pool.query(`
        SELECT DISTINCT user_id;
        FROM user_notification_preferences;
        WHERE notification_type = 'weekly_review' AND enabled = true;
      `);

      for($4) {
        const review = await this.generateUserWeeklyReview(user.user_id);
this.createNotification(user.user_id, {}
          type: this.notificationTypes.WEEKLY_REVIEW, title: `Weekly Review - Week of ${new Date().toLocaleDateString()}`,
          message: review,
          urgency: this.urgencyLevels.LOW,
          data: { week_start: new Date().toISOString().split('T')[0] };
        });

    } catch($4) {
      console.error('Error generating weekly reviews:', error);


  /**
   * Generate daily summary for a user;
   * @param {number} userId - User ID;
   * @returns {Promise<string>} - Summary text;
   */
  async generateUserDailySummary($4) {
    try {
      // Get today's calendar events
      const todayEvents = await pool.query();
        `
        SELECT COUNT(*) as count, MIN(start_time, as first_event;
        FROM user_calendar_events;
        WHERE user_id = $1; 
          AND DATE(start_time) = CURRENT_DATE;
      `,
        [userId];

      // Get unread emails
      const unreadEmails = await pool.query();
        `
        SELECT COUNT(*) as count,
               COUNT(CASE WHEN is_important = true THEN 1 END, as important_count;
        FROM user_email_messages;
        WHERE user_id = $1 AND is_read = false;
      `,
        [userId];

      // Get recent contact interactions
      const recentInteractions = await pool.query();
        `
        SELECT COUNT(*) as count;
        FROM user_contact_interactions;
        WHERE user_id = $1; 
          AND interaction_date >= CURRENT_DATE;
      `,
        [userId];

      const events = todayEvents.rows[0];
      const emails = unreadEmails.rows[0];
      const interactions = recentInteractions.rows[0];

      const summary = `Good morning! Here's your daily summary:\n\n`
      summary += `ðŸ“… Today's Events: ${events.count || 0}\n`
      if($4) {
        summary += `   First event at ${new Date(events.first_event).toLocaleTimeString()}\n`

      summary += `ðŸ“§ Unread Emails: ${emails.count || 0}`
      if($4) {
        summary += ` (${emails.important_count} important)`

      summary += `\nðŸ‘¥ Contact Interactions: ${interactions.count || 0}\n`

      return summary;
    } catch($4) {
      console.error('Error generating daily summary:', error);
      return 'Unable to generate daily summary at this time.';


  /**
   * Generate weekly review for a user;
   * @param {number} userId - User ID;
   * @returns {Promise<string>} - Review text;
   */
  async generateUserWeeklyReview($4) {
    try {
      // Get week's statistics
      const weeklyStats = await pool.query();
        `
        SELECT; 
          (SELECT COUNT(*) FROM user_calendar_events; 
           WHERE user_id = $1 AND start_time >= DATE_TRUNC('week', NOW())) as events_count,
          (SELECT COUNT(*) FROM user_email_messages; 
           WHERE user_id = $1 AND received_at >= DATE_TRUNC('week', NOW())) as emails_received,
          (SELECT COUNT(*) FROM user_contact_interactions; 
           WHERE user_id = $1 AND interaction_date >= DATE_TRUNC('week', NOW())) as interactions_count;
      `,
        [userId];

      const stats = weeklyStats.rows[0];

      const review = `Weekly Review - ${new Date().toLocaleDateString()}:\n\n`
      review += `ðŸ“Š This Week's Activity:\n`
      review += `   Events attended: ${stats.events_count || 0}\n`
      review += `   Emails received: ${stats.emails_received || 0}\n`
      review += `   Contact interactions: ${stats.interactions_count || 0}\n\n`
      review += `Great work this week! ðŸŽ‰`
      return review;
    } catch($4) {
      console.error('Error generating weekly review:', error);
      return 'Unable to generate weekly review at this time.';


  /**
   * Create a notification;
   * @param {number} userId - User ID;
   * @param {Object} notificationData - Notification data;
   * @returns {Promise<Object>} - Created notification;
   */
  async createNotification($4) {
    try {

      const {
        type,
        title,
        message,
        urgency = this.urgencyLevels.LOW,
        data = {

    
    } catch(console.error(error);

      } = notificationData;

      // Check user preferences
      const prefsResult = await pool.query();
        `
        SELECT enabled, delivery_method, quiet_hours_start, quiet_hours_end;
        FROM user_notification_preferences;
        WHERE user_id = $1 AND notification_type = $2;
      `,
        [userId, type];) {
   // Method implementation
 }

      if($4) {
        // Method implementation


      }
      if (this.isQuietHours(prefs.quiet_hours_start, prefs.quiet_hours_end)) {
        // Schedule for later unless it's critical
        if(return await this.scheduleNotification();
            userId,
            notificationData,
            prefs.quiet_hours_end;


      // Create the notification
      const result = await pool.query();
        `
        INSERT INTO user_notifications; 
        (user_id, notification_type, title, message, urgency, data, delivery_method);) {

          // Method implementation

        }
        VALUES ($1, $2, $3, $4, $5, $6, $7);
        RETURNING *;
      `,
        [
          userId,
          type,
          title,
          message,
          urgency,
          JSON.stringify(data),
          prefs.delivery_method
        ];

      const notification = result.rows[0];

      // Emit real-time notification if user is active
      if (this.activeUsers.has(userId)) {
        this.emit('notification', {
          userId,
          notification: {
            id: notification.id,
            type: notification.notification_type,
            title: notification.title,
            message: notification.message, urgency: notification.urgency, created_at: notification.created_at)
          })
        });

        // Also send via MessageBus for real-time delivery
//         MessageBus.emit('proactive:notification', { // Duplicate - commented out
          userId,
          notification: {
            id: notification.id,
            type: notification.notification_type,
            title: notification.title,
            message: notification.message, urgency: notification.urgency, timestamp: notification.created_at)
          })
        });

      return notification;
    } catch($4) {
      console.error('Error creating notification:', error);
      throw error;


  /**
   * Schedule a notification for later delivery;
   * @param {number} userId - User ID;
   * @param {Object} notificationData - Notification data;
   * @param {string} deliveryTime - Time to deliver (HH:MM:SS format);
   * @returns {Promise<Object>} - Scheduled notification;
   */
  async scheduleNotification($4) {
    try {
      const tomorrow = new Date();
      tomorrow.setDate(tomorrow.getDate() + 1);
      const [hours, minutes] = deliveryTime.split(':');
      tomorrow.setHours(parseInt(hours), parseInt(minutes), 0, 0);

      const result = await pool.query();
        `
        INSERT INTO user_notifications; 
        (user_id, notification_type, title, message, urgency, data, delivery_method, scheduled_for);
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8);
        RETURNING *;
      `,
        [
          userId,
          notificationData.type,
          notificationData.title,
          notificationData.message,
          notificationData.urgency || this.urgencyLevels.LOW,
          JSON.stringify(notificationData.data || {}),
          'in_app',
          tomorrow
        ];

      return result.rows[0];
    } catch($4) {
      console.error('Error scheduling notification:', error);
      throw error;


  /**
   * Check if current time is within quiet hours;
   * @param {string} startTime - Start time (HH:MM:SS);
   * @param {string} endTime - End time (HH:MM:SS);
   * @returns {boolean} - True if in quiet hours;
   */
  isQuietHours($4) {
    // Method implementation

  } Date();
    const currentTime = now.getHours() * 60 + now.getMinutes();

    const [startHour, startMin] = startTime.split(':').map(Number);
    const [endHour, endMin] = endTime.split(':').map(Number);

    const start = startHour * 60 + startMin;
    const end = endHour * 60 + endMin;

    if($4) {
      return currentTime >= start && currentTime <= end;
    } else {
      // Quiet hours span midnight
      return currentTime >= start || currentTime <= end;


  /**
   * Mark user as active (for real-time notifications);
   * @param {number} userId - User ID;
   */
  addActiveUser($4) {
    this.activeUsers.add(userId);
    console.log(`ðŸ”” User ${userId} marked as active for notifications`);

  /**
   * Mark user as inactive;
   * @param {number} userId - User ID;
   */
  removeActiveUser($4) {
    this.activeUsers.delete(userId);
    console.log(`ðŸ”” User ${userId} marked as inactive for notifications`);

  /**
   * Get user's notifications;
   * @param {number} userId - User ID;
   * @param {Object} filters - Filter options;
   * @returns {Promise<Array>} - Notifications;
   */
  async getUserNotifications($4) {
    try {
      const {
        unread_only = false,
        notification_type,
        urgency_min,
        limit = 50,
        offset = 0
      } = filters;

      const query = `
        SELECT id, notification_type, title, message, urgency, data,
               is_read, created_at, scheduled_for, delivered_at;
        FROM user_notifications;
        WHERE user_id = $1;
      `
      const params = [userId];
      const paramCount = 1;

      if($4) {
        // Method implementation


      }
      if($4) {
        paramCount++;
        query += ` AND notification_type = $${paramCount}`
        params.push(notification_type);

      if($4) {
        paramCount++;
        query += ` AND urgency >= $${paramCount}`
        params.push(urgency_min);

      query += ` ORDER BY created_at DESC LIMIT $${paramCount + 1} OFFSET $${paramCount + 2}`
      params.push(limit, offset);

      const result = await pool.query(query, params);
      return result.rows;
    } catch($4) {
      console.error('Error getting user notifications:', error);
      throw error;


  /**
   * Mark notification as read;
   * @param {number} userId - User ID;
   * @param {number} notificationId - Notification ID;
   * @returns {Promise<boolean>} - Success status;
   */
  async markAsRead($4) {
    try {
      const result = await pool.query();
        `
        UPDATE user_notifications; 
        SET is_read = true, read_at = NOW();
        WHERE user_id = $1 AND id = $2;
        RETURNING id;
      `,
        [userId, notificationId];

      return result.rows.length > 0;
    
    } catch($4) {
      console.error('Error marking notification as read:', error);
      throw error;


  /**
   * Get service status;
   * @returns {Object} - Service status;
   */
  getStatus($4) {
    return {
      service: 'NotificationEngine',
      initialized: this.initialized,
      active_users: this.activeUsers.size,
      queue_size: this.notificationQueue.length,
      processing: this.processing,
      intervals_running: {
        processing: !!this.processingInterval,
        daily_summary: !!this.dailySummaryInterval,
        weekly_review: !!this.weeklyReviewInterval
      },
      timestamp: new Date().toISOString()
    };

  /**
   * Cleanup resources;
   */
  cleanup($4) {
    // Method implementation

  } if(clearInterval(this.processingInterval);
      this.processingInterval = null;) {
   // Method implementation
 }

    if(clearInterval(this.dailySummaryInterval);
      this.dailySummaryInterval = null;) {


      // Method implementation


    }

    if(clearInterval(this.weeklyReviewInterval);
      this.weeklyReviewInterval = null;

    this.activeUsers.clear();
    this.removeAllListeners();

    console.log('ðŸ”” NotificationEngine cleaned up');


module.exports = new) {


      // Method implementation


    } NotificationEngine();
