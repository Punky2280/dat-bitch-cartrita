/* global process, console */
const { google } = require('googleapis');
const pool = require('../db');
const EncryptionService = require('./SimpleEncryption');
const GoogleAPIService = require('./GoogleAPIService');

class CalendarService {
  constructor($4) {
    this.initialized = false;
    this.calendar = null;
    this.googleAPI = GoogleAPIService;
    console.log('ðŸ“… CalendarService initialized with enhanced Google API integration');

  /**
   * Initialize Calendar service with user's OAuth credentials;
   * @param {number} userId - User ID;
   * @returns {Promise<boolean>} - Success status;
   */
  async initializeForUser($4) {
    try {
      // Use enhanced GoogleAPIService for user authentication
      const userAPIs = await this.googleAPI.getUserAPIs(userId);
      this.calendar = userAPIs.calendar;
      this.currentUserId = userId;
      this.initialized = true;

      console.log(`âœ… Calendar service initialized for user ${userId}`);
      return true;
    } catch($4) {
      console.error('Error initializing Calendar service:', error);

      // Fallback to legacy authentication method
      try {
        console.log('ðŸ”„ Attempting legacy authentication fallback...');
        return await this.legacyInitializeForUser(userId);
      
      } catch(console.error('Legacy fallback also failed:', fallbackError);
        throw error;



  /**
   * Legacy initialization) {
   // Method implementation
 } method (backup);
   * @param {number} userId - User ID;
   * @returns {Promise<boolean>} - Success status;
   */
  async legacyInitializeForUser($4) {
    try {
// Get user's Google Calendar API key from vault
      const keyResult = await pool.query();
        `
        SELECT uak.key_data, uak.encrypted_metadata;
        FROM user_api_keys uak;
        JOIN api_providers ap ON uak.provider_id = ap.id;
        WHERE uak.user_id = $1 AND ap.name = 'google' AND uak.is_active = true;
        LIMIT 1;
      `,
        [userId];

      if($4) {
        // Method implementation


      } Error();
          'Google Calendar API credentials not found. Please connect your Google account.';

      

    } catch($4) {
  console.error(error);

      const row = keyResult.rows[0];
      const decryptedKey = EncryptionService.decrypt(row.key_data);
      const metadata = row.encrypted_metadata ? JSON.parse(EncryptionService.decrypt(row.encrypted_metadata)) : {};

      // Initialize Google OAuth2 client
      const oauth2Client = new google.auth.OAuth2();
        metadata.client_id,
        metadata.client_secret,
        metadata.redirect_uri;

      oauth2Client.setCredentials({
        access_token: decryptedKey,
        refresh_token: metadata.refresh_token, scope: metadata.scope, token_type: 'Bearer')
        expiry_date: metadata.expiry_date)
      });

      // Initialize Calendar API client
      this.calendar = google.calendar({ version: 'v3', auth: oauth2Client });
      this.currentUserId = userId;
      this.initialized = true;

      return true;
    } catch($4) {
      console.error('Error in legacy calendar initialization:', error);
      throw error;


  /**
   * Sync user's calendars from Google;
   * @param {number} userId - User ID;
   * @returns {Promise<Object>} - Sync results;
   */
  async syncCalendars($4) {
this.initializeForUser(userId);
    try {
      // Fetch user's calendar list
      const calendarListResponse = await this.calendar.calendarList.list({
        minAccessRole: 'reader', showDeleted: false, showHidden: false)
      });

      const calendars = calendarListResponse.data.items || [];
      const syncResults = {
        calendars_synced: 0,
        events_synced: 0,
        errors: []
      };

      for($4) {
        try {
          // Store/update calendar sync info
await pool.query();
            `
            INSERT INTO user_calendar_sync; 
            (user_id, calendar_id, calendar_name, provider, calendar_color, 
             is_primary, access_role, sync_enabled, last_sync_at);
            VALUES ($1, $2, $3, 'google', $4, $5, $6, true, NOW());
            ON CONFLICT (user_id, calendar_id, provider);
            DO UPDATE SET;
              calendar_name = EXCLUDED.calendar_name,
              calendar_color = EXCLUDED.calendar_color,
              is_primary = EXCLUDED.is_primary,
              access_role = EXCLUDED.access_role,
              last_sync_at = NOW();
          `,
            [
              userId,
              calendar.id,
              calendar.summary,
              calendar.backgroundColor,
              calendar.primary || false,
              calendar.accessRole
            ];

          // Sync events for this calendar
          const eventsSynced = await this.syncCalendarEvents();
            userId,
            calendar.id;

          syncResults.events_synced += eventsSynced;
          syncResults.calendars_synced++;
        
        } catch($4) {
          console.error(`Error syncing calendar ${calendar.id}:`)
            calendarError);
          syncResults.errors.push({
            calendar_id: calendar.id, error: calendarError.message)
          });


      return syncResults;
    } catch($4) {
      console.error('Error syncing calendars:', error);
      throw error;


  /**
   * Sync events for a specific calendar;
   * @param {number} userId - User ID;
   * @param {string} calendarId - Calendar ID;
   * @returns {Promise<number>} - Number of events synced;
   */
  async syncCalendarEvents($4) {
    try {
      // Get last sync token for incremental sync
      const syncResult = await pool.query();
        'SELECT sync_token FROM user_calendar_sync WHERE user_id = $1 AND calendar_id = $2',
        [userId, calendarId];

      const syncToken = syncResult.rows[0]?.sync_token;
      const now = new Date();
      const threeMonthsAgo = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);

      const eventsParams = {
        calendarId: calendarId,
        timeMin: threeMonthsAgo.toISOString(),
        maxResults: 1000,
        singleEvents: true,
        orderBy: 'startTime'
      };

      if(eventsParams.syncToken = syncToken;
        delete eventsParams.timeMin; // Can't use both syncToken and timeMin

      const eventsResponse = await this.calendar.events.list(eventsParams);
      const events = eventsResponse.data.items || [];
      const eventsSynced = 0;) {


        // Method implementation


      }

      for($4) {
        try {
          if($4) {
            // Remove cancelled events
await pool.query();
              'DELETE FROM user_calendar_events WHERE user_id = $1 AND calendar_id = $2 AND event_id = $3',
              [userId, calendarId, event.id];

          } else {
            // Insert or update event
this.storeCalendarEvent(userId, calendarId, event);
            eventsSynced++;

        } catch($4) {
          console.error(`Error processing event ${event.id}:`, eventError);


      // Update sync token for next incremental sync
      if(await pool.query();
          'UPDATE user_calendar_sync SET sync_token = $1, last_sync_at =) {

        // Method implementation

      } NOW() WHERE user_id = $2 AND calendar_id = $3',
          [eventsResponse.data.nextSyncToken, userId, calendarId];

      return eventsSynced;
    } catch($4) {
      console.error('Error syncing calendar events:', error);
      throw error;


  /**
   * Store a calendar event in the database;
   * @param {number} userId - User ID;
   * @param {string} calendarId - Calendar ID;
   * @param {Object} event - Google Calendar event object;
   */
  async storeCalendarEvent($4) {
    try {
      const startTime = this.parseEventDateTime(event.start);
      const endTime = this.parseEventDateTime(event.end);

      const attendees = event.attendees;
        ? event.attendees.map(attendee => ({
            email: attendee.email
            name: attendee.displayName, status: attendee.responseStatus, optional: attendee.optional)
          }));
        : [];

      const reminderMinutes = event.reminders?.overrides ? event.reminders.overrides.map(r => r.minutes) : [];
await pool.query();
        `
        INSERT INTO user_calendar_events; 
        (user_id calendar_id, event_id, title, description, start_time, end_time, 
         timezone, location, attendees, recurrence_rule, reminder_minutes, status, 
         visibility, meeting_url, synced_at);
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, NOW());
        ON CONFLICT (user_id, calendar_id, event_id);
        DO UPDATE SET;
          title = EXCLUDED.title,
          description = EXCLUDED.description,
          start_time = EXCLUDED.start_time,
          end_time = EXCLUDED.end_time,
          timezone = EXCLUDED.timezone,
          location = EXCLUDED.location,
          attendees = EXCLUDED.attendees,
          recurrence_rule = EXCLUDED.recurrence_rule,
          reminder_minutes = EXCLUDED.reminder_minutes,
          status = EXCLUDED.status,
          visibility = EXCLUDED.visibility,
          meeting_url = EXCLUDED.meeting_url,
          synced_at = NOW(),
          updated_at = NOW();
      `,
        [
          userId,
          calendarId,
          event.id,
          event.summary || 'Untitled Event',
          event.description || null,
          startTime,
          endTime,
          event.start?.timeZone || 'UTC',
          event.location || null,
          JSON.stringify(attendees),
          event.recurrence ? event.recurrence[0] : null,
          reminderMinutes,
          event.status || 'confirmed',
          event.visibility || 'default',
          this.extractMeetingUrl(event.description || event.location || '')
        ];

    } catch($4) {
      console.error('Error storing calendar event:', error);
      throw error;


  /**
   * Create a new calendar event;
   * @param {number} userId - User ID;
   * @param {Object} eventData - Event data;
   * @returns {Promise<Object>} - Created event;
   */
  async createEvent($4) {
this.initializeForUser(userId);
    try {
      const {
        calendarId = 'primary',
        title,
        description,
        startTime,
        endTime,
        timezone = 'UTC',
        location,
        attendees = [],
        reminderMinutes = [15]
      } = eventData;

      const googleEvent = {
        summary: title,
        description: description,
        start: {
          dateTime: new Date(startTime).toISOString(),
          timeZone: timezone
        },
        end: {
          dateTime: new Date(endTime).toISOString(),
          timeZone: timezone
        },
        location: location,
        attendees: attendees.map(email => ({ email })),
        reminders: {
          useDefault: false,
          overrides: reminderMinutes.map(minutes => ({
            method: 'popup'
            minutes: minutes)
          }))

      };

      const response = await this.calendar.events.insert({
        calendarId: calendarId, resource: googleEvent, sendUpdates: 'all')
      });

      // Store in local database
this.storeCalendarEvent(userId, calendarId, response.data);
      return response.data;
    } catch($4) {
      console.error('Error creating calendar event:', error);
      throw error;


  /**
   * Update an existing calendar event;
   * @param {number} userId - User ID;
   * @param {string} eventId - Event ID;
   * @param {Object} eventData - Updated event data;
   * @returns {Promise<Object>} - Updated event;
   */
  async updateEvent($4) {
this.initializeForUser(userId);
    try {
      const { calendarId = 'primary', ...updateData } = eventData;

      // Get current event
      const currentEvent = await this.calendar.events.get({
        calendarId: calendarId
        eventId: eventId)
      });

      // Merge updates with current event
      const updatedEvent = {
        ...currentEvent.data,
        summary: updateData.title || currentEvent.data.summary,
        description: updateData.description || currentEvent.data.description,
        location: updateData.location || currentEvent.data.location
      };

      if($4) {
        updatedEvent.start = {
          dateTime: new Date(updateData.startTime).toISOString(),
          timeZone: updateData.timezone || currentEvent.data.start.timeZone
        };

      if($4) {
        updatedEvent.end = {
          dateTime: new Date(updateData.endTime).toISOString(),
          timeZone: updateData.timezone || currentEvent.data.end.timeZone
        };

      if($4) {
        updatedEvent.attendees = updateData.attendees.map(email => ({ email }));

      const response = await this.calendar.events.update({
        calendarId: calendarId
        eventId: eventId, resource: updatedEvent, sendUpdates: 'all')
      });

      // Update in local database
this.storeCalendarEvent(userId, calendarId, response.data);
      return response.data;
    } catch($4) {
      console.error('Error updating calendar event:', error);
      throw error;


  /**
   * Delete a calendar event;
   * @param {number} userId - User ID;
   * @param {string} eventId - Event ID;
   * @param {string} calendarId - Calendar ID;
   * @returns {Promise<boolean>} - Success status;
   */
  async deleteEvent($4) {
this.initializeForUser(userId);
    try {
this.calendar.events.delete({}
        calendarId: calendarId, eventId: eventId, sendUpdates: 'all')
      });
      // Remove from local database
await pool.query();
        'DELETE FROM user_calendar_events WHERE user_id = $1 AND calendar_id = $2 AND event_id = $3',
        [userId, calendarId, eventId];

      return true;
    } catch($4) {
      console.error('Error deleting calendar event:', error);
      throw error;


  /**
   * Get user's calendar events with filtering;
   * @param {number} userId - User ID;
   * @param {Object} filters - Filter options;
   * @returns {Promise<Array>} - Calendar events;
   */
  async getEvents($4) {
    try {
      const {
        startDate,
        endDate,
        calendarIds,
        limit = 100,
        offset = 0
      } = filters;

      const query = `
        SELECT ce.*, cs.calendar_name, cs.calendar_color, cs.is_primary;
        FROM user_calendar_events ce;
        JOIN user_calendar_sync cs ON ce.calendar_id = cs.calendar_id AND ce.user_id = cs.user_id;
        WHERE ce.user_id = $1;
      `
      const params = [userId];
      const paramCount = 1;

      if($4) {
        paramCount++;
        query += ` AND ce.start_time >= $${paramCount}`
        params.push(startDate);

      if($4) {
        paramCount++;
        query += ` AND ce.end_time <= $${paramCount}`
        params.push(endDate);

      if($4) {
        // Method implementation


      } ANY($${paramCount})`
        params.push(calendarIds);

      query += ` ORDER BY ce.start_time ASC LIMIT $${paramCount + 1} OFFSET $${paramCount + 2}`
      params.push(limit, offset);

      const result = await pool.query(query, params);
      return result.rows;
    } catch($4) {
      console.error('Error getting calendar events:', error);
      throw error;


  /**
   * Check availability for a given time period;
   * @param {number} userId - User ID;
   * @param {string} startTime - Start time;
   * @param {string} endTime - End time;
   * @param {Array} calendarIds - Calendar IDs to check;
   * @returns {Promise<Object>} - Availability information;
   */
  async checkAvailability($4) {
    try {
const query = `
        SELECT COUNT(*) as conflicting_events,
               ARRAY_AGG(title, as conflicting_titles;
        FROM user_calendar_events;
        WHERE user_id = $1;
          AND status != 'cancelled';
          AND ();
            (start_time <= $2 AND end_time > $2, OR;
            (start_time < $3 AND end_time >= $3, OR;
            (start_time >= $2 AND end_time <= $3);

      `
      const params = [userId, startTime, endTime];

      if($4) {
        // Method implementation


      } ANY($4)`
        params.push(calendarIds);
      

    } catch($4) {
  console.error(error);

      const result = await pool.query(query, params);
      const row = result.rows[0];

      return {
        is_available: parseInt(row.conflicting_events) === 0,
        conflicting_events: parseInt(row.conflicting_events),
        conflicting_titles: row.conflicting_titles || []
      };
    } catch(console.error('Error checking availability:', error);
      throw error;


  /**
   * Find optimal meeting times based on attendee) {
   // Method implementation
 } availability (Enhanced);
   * @param {number} userId - User ID;
   * @param {Object} constraints - Meeting constraints;
   * @returns {Promise<Array>} - Suggested time slots;
   */
  async suggestMeetingTimes($4) {
    try {
      const {
        duration = 60, // minutes
        attendees = [],
        startDate,
        endDate,
        workHours = { start: '09:00', end: '17:00' },
        timezone = 'UTC'
      } = constraints;

      // Try to use enhanced calendar service for AI-powered suggestions
      try {
        const enhancedService =null;
this.googleAPI.getEnhancedCalendarService(userId);
        const aiSuggestions =null;
enhancedService.suggestOptimalTimes(constraints);
        if($4) {
          console.log('âœ¨ Using AI-powered time suggestions');
          return aiSuggestions.map(suggestion => ({
            start_time: suggestion.time, end_time: suggestion.time, // Will be calculated based on duration, confidence: suggestion.confidence, reason: suggestion.reason)
          }));

      } catch(console.log('ðŸ“… Falling back to standard time suggestions');

      const suggestions = [];
      const start = new) {
   // Method implementation
 } Date(startDate);
      const end = new Date(endDate);

      for (const d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
        // Skip weekends
        if (d.getDay() === 0 || d.getDay() === 6, continue;

        // Check hourly slots during work hours
        for ();
          const hour = parseInt(workHours.start);
          hour < parseInt(workHours.end);
          hour++;
        ) {
          const slotStart = new Date(d);
          slotStart.setHours(hour, 0, 0, 0);

          const slotEnd = new Date(slotStart);
          slotEnd.setMinutes(slotEnd.getMinutes() + duration);

          // Check if this slot is available
          const availability = await this.checkAvailability();
            userId,
            slotStart.toISOString(),
            slotEnd.toISOString();

          if($4) {
            suggestions.push({}
              start_time: slotStart.toISOString(),
              end_time: slotEnd.toISOString(),
              confidence: 0.8, // Standard confidence for rule-based suggestions
              reason: 'Available time slot during work hours'
            });

          // Limit suggestions
          if($4) {
      console.error('Error suggesting meeting times:', error);
      throw error;


  /**
   * Get enhanced calendar analytics;
   * @param {number} userId - User ID;
   * @param {number} days - Number of days to analyze;
   * @returns {Promise<Object>} - Enhanced analytics;
   */
  async getEnhancedAnalytics($4) {
    try {
this.initializeForUser(userId);
      // Try to get enhanced analytics from GoogleAPIService
      try {
        const enhancedService =null;
this.googleAPI.getEnhancedCalendarService(userId);
        const scheduleAnalysis = await enhancedService.analyzeSchedule(days);

        // Combine with our database statistics
        const dbStats = await this.getBasicStats(userId, days);

        return {
          ...dbStats,
          ai_analysis: scheduleAnalysis,
          productivity_insights: scheduleAnalysis.productivity_insights || [],
          busy_hours_analysis: scheduleAnalysis.busy_hours || {},
          meeting_patterns: scheduleAnalysis.meeting_patterns || {};
        };
      } catch(console.log('ðŸ“Š Using basic analytics only');
        return await this.getBasicStats(userId, days);

    }) {
   // Method implementation
 } catch($4) {
      console.error('Error getting enhanced analytics:', error);
      throw error;


  /**
   * Get basic statistics from database;
   * @param {number} userId - User ID;
   * @param {number} days - Number of days;
   * @returns {Promise<Object>} - Basic statistics;
   */
  async getBasicStats($4) {
    // Method implementation

  } 
        COUNT(*) as total_events,
        COUNT(CASE WHEN start_time >= NOW() THEN 1 END, as upcoming_events,
        COUNT(CASE WHEN start_time < NOW() AND end_time > NOW() THEN 1 END, as current_events,
        COUNT(DISTINCT calendar_id, as active_calendars,
        AVG(EXTRACT(EPOCH FROM (end_time - start_time))/60, as avg_duration_minutes
      FROM user_calendar_events;
      WHERE user_id = $1; 
        AND start_time >= NOW() - INTERVAL '${parseInt(days)} days';
        AND status != 'cancelled';
    `

    const result = await pool.query(statsQuery, [userId]);
    const stats = result.rows[0];

    return {
      total_events: parseInt(stats.total_events),
      upcoming_events: parseInt(stats.upcoming_events),
      current_events: parseInt(stats.current_events),
      active_calendars: parseInt(stats.active_calendars),
      avg_duration_minutes: parseFloat(stats.avg_duration_minutes) || 0
    };

  /**
   * Helper: Parse Google Calendar datetime;
   * @param {Object} dateTime - Google Calendar date/time object
   * @returns {Date} - Parsed date;
   */
  parseEventDateTime($4) {
    // Method implementation

  }

    if($4) {
      // Method implementation


    } Date(dateTime.dateTime);
    } else if($4) {
   // Method implementation
 } Date(dateTime.date + 'T00:00:00Z');

    return null;

  /**
   * Helper: Extract meeting URL from text;
   * @param {string} text - Text to search;
   * @returns {string|null} - Meeting URL or null;
   */
  extractMeetingUrl(if (!text, return null;

    const urlRegex = /(https?://[^\s]+)/g;
    const urls = text.match(urlRegex);) {

    // Method implementation

  }

    if($4) {
      // Method implementation


    } for($4) {
   // Method implementation
 } if (url.includes(platform)) {
          return url;



    return urls[0]; // Return first URL if no meeting platform detected

  /**
   * Test calendar API connectivity;
   * @param {number} userId - User ID;
   * @returns {Promise<Object>} - Test results;
   */
  async testConnectivity($4) {
    try {
this.initializeForUser(userId);
      // Test basic calendar access
      const calendarList = await this.calendar.calendarList.list({
        maxResults: 1)
      });

      return {
        success: true,
        calendars_accessible: calendarList.data.items?.length || 0,
        enhanced_features_available: true,
        message: 'Calendar API connectivity verified'
      };
    } catch($4) {
      return {
        success: false,
        error: error.message,
        enhanced_features_available: false,
        message: 'Calendar API connectivity failed'
      };


  /**
   * Get service status;
   * @returns {Object} - Service status;
   */
  getStatus($4) {
    return {
      service: 'CalendarService',
      version: '2.0-enhanced',
      initialized: this.initialized,
      current_user: this.currentUserId || null,
      google_api_service: this.googleAPI ? 'connected' : 'disconnected',
      features: {
        basic_calendar_ops: true,
        ai_powered_suggestions: true,
        enhanced_analytics: true,
        smart_scheduling: true
      },
      timestamp: new Date().toISOString()
    };


module.exports = new CalendarService();
